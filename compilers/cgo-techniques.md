# CGO Techniques
List of CGO & CPU techniques, and the categories of each

1. In a LS[^leansystem] with macro & generative, do we miss them? beyond dev-comfort.
2. The programming languages like C++, what will we miss in terms of speed (other than abstractions). (They are better than assembly, I know)

About 1:
1. The wont miss cases
    * to trick CPU from the narrow compressed-code (ISA). (e.g. cache)
    * MLIR: streamlining of the
    * the instruciton-level paralelism?
    * legacy code
    * automatic optimisaiton so that the user does not have to "think".
       * <!-- (alternatuve: use multiple realisaitons! one can be used to test antoher! test-level latching, runtime-level latching, etc) -->
       * They want to have one reference of truth. <!-- nope. OO can do better. -->
    * Making old code, optimised for the new architecture (FORTRAN approach)

About 2:
2. The beyond-...., .... .

HW:
* Pipelining. Without that?

## CGO

## HW (CPU/GPU)

